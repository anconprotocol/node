/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export interface InvoiceAssetCDInterface extends utils.Interface {
  functions: {
    "dataProvider()": FunctionFragment;
    "fee()": FunctionFragment;
    "lendingPool()": FunctionFragment;
    "owner()": FunctionFragment;
    "requestCount()": FunctionFragment;
    "token()": FunctionFragment;
    "depositCollateral(address,uint256,bool)": FunctionFragment;
    "approveBorrower(address,uint256,address)": FunctionFragment;
    "borrow(address,uint256,uint256,uint16,address)": FunctionFragment;
    "repayBorrower(uint256,address)": FunctionFragment;
    "withdrawCollateral(address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "dataProvider",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "fee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lendingPool",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "requestCount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "token", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "depositCollateral",
    values: [string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "approveBorrower",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [string, BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "repayBorrower",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawCollateral",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "dataProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lendingPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "requestCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveBorrower",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "repayBorrower",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawCollateral",
    data: BytesLike
  ): Result;

  events: {};
}

export interface InvoiceAssetCD extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: InvoiceAssetCDInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    dataProvider(overrides?: CallOverrides): Promise<[string]>;

    fee(overrides?: CallOverrides): Promise<[BigNumber]>;

    lendingPool(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    requestCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    token(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Deposits collateral into the Aave, to enable credit delegation This would be called by the delegator.
     * @param amount The amount to be deposited as collateral
     * @param asset The asset to be deposited as collateral
     * @param isPull Whether to pull the funds from the caller, or use funds sent to this contract  User must have approved this contract to pull funds if `isPull` = true
     */
    depositCollateral(
      asset: string,
      amount: BigNumberish,
      isPull: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Approves the borrower to take an uncollaterised loan
     * @param amount The amount the borrower is allowed to borrow (i.e. their line of credit)
     * @param asset The asset they are allowed to borrow Add permissions to this call, e.g. only the owner should be able to approve borrowers!
     * @param borrower The borrower of the funds (i.e. delgatee)
     */
    approveBorrower(
      borrower: string,
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    borrow(
      assetToBorrow: string,
      amountToBorrowInWei: BigNumberish,
      interestRateMode: BigNumberish,
      referralCode: BigNumberish,
      delegatorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Repay an uncollaterised loan
     * @param amount The amount to repay
     * @param asset The asset to be repaid User calling this function must have approved this contract with an allowance to transfer the tokens You should keep internal accounting of borrowers, if your contract will have multiple borrowers
     */
    repayBorrower(
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated
     * @param asset The underlying asset to withdraw Add permissions to this call, e.g. only the owner should be able to withdraw the collateral!
     */
    withdrawCollateral(
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  dataProvider(overrides?: CallOverrides): Promise<string>;

  fee(overrides?: CallOverrides): Promise<BigNumber>;

  lendingPool(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  requestCount(overrides?: CallOverrides): Promise<BigNumber>;

  token(overrides?: CallOverrides): Promise<string>;

  /**
   * Deposits collateral into the Aave, to enable credit delegation This would be called by the delegator.
   * @param amount The amount to be deposited as collateral
   * @param asset The asset to be deposited as collateral
   * @param isPull Whether to pull the funds from the caller, or use funds sent to this contract  User must have approved this contract to pull funds if `isPull` = true
   */
  depositCollateral(
    asset: string,
    amount: BigNumberish,
    isPull: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Approves the borrower to take an uncollaterised loan
   * @param amount The amount the borrower is allowed to borrow (i.e. their line of credit)
   * @param asset The asset they are allowed to borrow Add permissions to this call, e.g. only the owner should be able to approve borrowers!
   * @param borrower The borrower of the funds (i.e. delgatee)
   */
  approveBorrower(
    borrower: string,
    amount: BigNumberish,
    asset: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  borrow(
    assetToBorrow: string,
    amountToBorrowInWei: BigNumberish,
    interestRateMode: BigNumberish,
    referralCode: BigNumberish,
    delegatorAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Repay an uncollaterised loan
   * @param amount The amount to repay
   * @param asset The asset to be repaid User calling this function must have approved this contract with an allowance to transfer the tokens You should keep internal accounting of borrowers, if your contract will have multiple borrowers
   */
  repayBorrower(
    amount: BigNumberish,
    asset: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated
   * @param asset The underlying asset to withdraw Add permissions to this call, e.g. only the owner should be able to withdraw the collateral!
   */
  withdrawCollateral(
    asset: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    dataProvider(overrides?: CallOverrides): Promise<string>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    lendingPool(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    requestCount(overrides?: CallOverrides): Promise<BigNumber>;

    token(overrides?: CallOverrides): Promise<string>;

    /**
     * Deposits collateral into the Aave, to enable credit delegation This would be called by the delegator.
     * @param amount The amount to be deposited as collateral
     * @param asset The asset to be deposited as collateral
     * @param isPull Whether to pull the funds from the caller, or use funds sent to this contract  User must have approved this contract to pull funds if `isPull` = true
     */
    depositCollateral(
      asset: string,
      amount: BigNumberish,
      isPull: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Approves the borrower to take an uncollaterised loan
     * @param amount The amount the borrower is allowed to borrow (i.e. their line of credit)
     * @param asset The asset they are allowed to borrow Add permissions to this call, e.g. only the owner should be able to approve borrowers!
     * @param borrower The borrower of the funds (i.e. delgatee)
     */
    approveBorrower(
      borrower: string,
      amount: BigNumberish,
      asset: string,
      overrides?: CallOverrides
    ): Promise<void>;

    borrow(
      assetToBorrow: string,
      amountToBorrowInWei: BigNumberish,
      interestRateMode: BigNumberish,
      referralCode: BigNumberish,
      delegatorAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Repay an uncollaterised loan
     * @param amount The amount to repay
     * @param asset The asset to be repaid User calling this function must have approved this contract with an allowance to transfer the tokens You should keep internal accounting of borrowers, if your contract will have multiple borrowers
     */
    repayBorrower(
      amount: BigNumberish,
      asset: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated
     * @param asset The underlying asset to withdraw Add permissions to this call, e.g. only the owner should be able to withdraw the collateral!
     */
    withdrawCollateral(asset: string, overrides?: CallOverrides): Promise<void>;
  };

  filters: {};

  estimateGas: {
    dataProvider(overrides?: CallOverrides): Promise<BigNumber>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    lendingPool(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    requestCount(overrides?: CallOverrides): Promise<BigNumber>;

    token(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deposits collateral into the Aave, to enable credit delegation This would be called by the delegator.
     * @param amount The amount to be deposited as collateral
     * @param asset The asset to be deposited as collateral
     * @param isPull Whether to pull the funds from the caller, or use funds sent to this contract  User must have approved this contract to pull funds if `isPull` = true
     */
    depositCollateral(
      asset: string,
      amount: BigNumberish,
      isPull: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Approves the borrower to take an uncollaterised loan
     * @param amount The amount the borrower is allowed to borrow (i.e. their line of credit)
     * @param asset The asset they are allowed to borrow Add permissions to this call, e.g. only the owner should be able to approve borrowers!
     * @param borrower The borrower of the funds (i.e. delgatee)
     */
    approveBorrower(
      borrower: string,
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    borrow(
      assetToBorrow: string,
      amountToBorrowInWei: BigNumberish,
      interestRateMode: BigNumberish,
      referralCode: BigNumberish,
      delegatorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Repay an uncollaterised loan
     * @param amount The amount to repay
     * @param asset The asset to be repaid User calling this function must have approved this contract with an allowance to transfer the tokens You should keep internal accounting of borrowers, if your contract will have multiple borrowers
     */
    repayBorrower(
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated
     * @param asset The underlying asset to withdraw Add permissions to this call, e.g. only the owner should be able to withdraw the collateral!
     */
    withdrawCollateral(
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    dataProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lendingPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    requestCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Deposits collateral into the Aave, to enable credit delegation This would be called by the delegator.
     * @param amount The amount to be deposited as collateral
     * @param asset The asset to be deposited as collateral
     * @param isPull Whether to pull the funds from the caller, or use funds sent to this contract  User must have approved this contract to pull funds if `isPull` = true
     */
    depositCollateral(
      asset: string,
      amount: BigNumberish,
      isPull: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Approves the borrower to take an uncollaterised loan
     * @param amount The amount the borrower is allowed to borrow (i.e. their line of credit)
     * @param asset The asset they are allowed to borrow Add permissions to this call, e.g. only the owner should be able to approve borrowers!
     * @param borrower The borrower of the funds (i.e. delgatee)
     */
    approveBorrower(
      borrower: string,
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    borrow(
      assetToBorrow: string,
      amountToBorrowInWei: BigNumberish,
      interestRateMode: BigNumberish,
      referralCode: BigNumberish,
      delegatorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Repay an uncollaterised loan
     * @param amount The amount to repay
     * @param asset The asset to be repaid User calling this function must have approved this contract with an allowance to transfer the tokens You should keep internal accounting of borrowers, if your contract will have multiple borrowers
     */
    repayBorrower(
      amount: BigNumberish,
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated
     * @param asset The underlying asset to withdraw Add permissions to this call, e.g. only the owner should be able to withdraw the collateral!
     */
    withdrawCollateral(
      asset: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
